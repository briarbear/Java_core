# Volatile 关键字
- 在 JDK1.2 之前，Java 的内存模型实现总是从主存（即共享内存）读取变量，是不需要进行特别的注意的。而随着 JVM 的成熟和优化，现在在多线程环境下 volatile 关键字的使用变得非常重要

- 在当前的 Java 内存模型下，线程可以把变量保存在本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致

- 要解决这个问题，就需要把变量声明为 volatile，这就指示 JVM，这个变量是不稳定的，每次使用它都到主存中进行读取。一般说来，多任务环境下，各任务间共享的变量都应该加 volatile 修饰符

- Volatile 修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值

- Java 语言规范中指出：为了获得最佳速度，允许线程保存共享成员变量的私有拷贝，而且只当线程进入或者离开同步代码块时才将私有拷贝与共享内存中的原始值进行比较

- 这样当多个线程同时与某个对象交互时，就必须注意到要让线程及时的得到共享成员变量的变化。而 volatile 关键字就是提示 JVM：对于这个成员变量，不能保存它的私有拷贝，而应直接与共享成员变量交互

- volatile 是一种稍弱的同步机制，在访问 volatile 变量时不会执行加锁操作，也就不会执行线程阻塞，因此 volatilei 变量是一种比 synchronized 关键字更轻量级的同步机制

**使用建议**：在两个或者更多的线程需要访问的成员变量上使用 volatile。当要访问的变量已在 synchronized 代码块中，或者为常量时，没必要使用 volatile
由于使用 volatile 屏蔽掉了 JVM 中必要的代码优化，所以在效率上比较低，因此一定在必要时才使用此关键字。
---
## 示例程序
   
   下面给出一段代码，通过其运行结果来说明使用关键字 volatile 产生的差异，但实际上遇到了意料之外的问题：
   -[volatile关键字1](http://wiki.jikexueyuan.com/project/java-concurrency/volatile1.html)
   按照以上的理论来分析，由于 value 变量不是 volatile 的，因此它在 main 线程中的改变不会被 Thread-0 线程（在 main 线程中新开启的线程）
   马上看到，因此 Thread-0 线程中的 while 循环不会直接退出，它会继续判断 missedIt 的值，由于 missedIt 是 volatile 的，当 main 线程中改变了 missedIt 时，Thread-0 线程会立即看到该变化，那么 if 语句中的代码便得到了执行的机会，由于此时 Thread-0 依然没有看到 value 值的变化，因此，currValue 的值为 10，继续向下执行，进入同步代码块，因为进入前后要将该线程内的变量值与共享内存中的原始值对比，进行校准，因此离开同步代码块后，Thread-0 便会察觉到 value 的值变为了 50，那么后面的 valueAfterSync 的值便为 50，最后从 break 跳出循环，结束 Thread-0 线程